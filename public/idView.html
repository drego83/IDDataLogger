<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<script type="text/javascript" src="https://momentjs.com/downloads/moment.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
	<link rel="stylesheet" type="text/css" href="https://npmcdn.com/flatpickr/dist/themes/airbnb.css">
	<link rel="stylesheet" type="text/css" href="css/datepicker.css">
	<link rel="stylesheet" type="text/css" href="css/idview.css">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
	<meta name="apple-mobile-web-app-capable" content="yes"/>
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
	<title>flexxxxxxxxxxx</title>
</head>
<body>
	<div class="container">
		<div class="row">
			<div class="element">
				<img src="car.png" class="responsive" alt="Car">
			</div>
			<div class="element doughnut">
				<canvas id="soc"></canvas>
			</div>
			<div class="element">
				<span class="bigvalue" id="range">300km</span>
				<span class="bigvalue" id="hvacstate">-------</span>
				<span class="bigvalue" id="hvactargettemp">(00.0°C)</span>
			</div>
		</div>
		<div class="row" id="chargingDisplay" style="display: none">
			<div class="element">
				<span class="bigvalue" id="chargingState">__chargestate__<br>__lockstate__</span>
			</div>
			<div class="element">
				<span class="bigvalue" id="chargePower">000kW</span>
				<span class="bigvalue" id="chargeKMPH">0 km/h</span>
			</div>
			<div class="element doughnut">
				<canvas id="chargingTimeRemaining"></canvas>
			</div>
		</div>
		<div class="row" id="timetravelrow">
			<input type="text" class="flatpickr" id="timetravel" placeholder="timetravel">
			<button id="timetravelclear" onclick="timetravelPicker.clear();">
				<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
				<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
			</svg></button>
		</div>
		<div class="row">
			<input type="text" class="flatpickr" id="graphDateRange">
		</div>
	</div>
	<script src="https://npmcdn.com/flatpickr/dist/l10n/de.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
</body>
<script type="text/javascript">
	flatpickr.localize(flatpickr.l10ns.de);
	let timetravelPicker = flatpickr("#timetravel", {dateFormat: "d.m.Y H:i", onChange: timetravelUser, enableTime: true, time_24hr: true});
	flatpickr("#graphDateRange", {mode: "range", dateFormat: "d.m.Y"});
	Chart.defaults.global.defaultFontColor = "#fff";
	class AnimatedValue{
		constructor(displayElement, startValue, unit, decimals = 0, scale = 1, animationLength = 1){
			this.element = displayElement;
			this.value = 0;
			this.setValue(startValue);
			this.unit = unit;
			
			this.decimals = decimals;
			this.scale = scale;
			this.animationLength = animationLength;
		}
		
		animate(timestamp){
			if(this.start == -1){
				this.start = timestamp;
			}
			let elapsed = timestamp - this.start;
			let animationProgress = elapsed / (this.animationLength*1000);
			
			this.element.innerHTML = (Math.round(this.value + ((this.newValue-this.value)*Chart.helpers.easing.effects.easeOutQuart(animationProgress))) / this.scale).toFixed(this.decimals) + this.unit;
			
			if(animationProgress > 1){
				this.value = this.newValue;
				this.element.innerHTML = (this.value / this.scale).toFixed(this.decimals) + this.unit;
				this.start = -1;
			}else{
				window.requestAnimationFrame(this.animate.bind(this));
			}
		}
		
		setValue(value){
			this.start = -1;
			this.newValue = parseFloat(value);
			window.requestAnimationFrame(this.animate.bind(this));
			
		}
	}
	class DoughnutValue{
		constructor(canvas, value, max, unit, legendName){
			this.canvas = canvas;
			this.value = value;
			this.max = max;
			this.unit = unit;
			this.legendName = legendName;
			
			this.animationProgress = 0;
			let plugin = {
				afterDraw: function(chart){
					//chart.controller.chartArea
					let ctx = chart.ctx;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillStyle = 'white';
					ctx.font = Chart.helpers.fontString(this.canvas.height/(6*this.chart.currentDevicePixelRatio), Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily)
					let legendOffset = this.chart.options.legend.display ? 15 : 0;
					ctx.fillText(
						Math.round(this.getInnerDisplayValue() * Chart.helpers.easing.effects.easeOutQuart(this.animationProgress))+this.unit,
						this.canvas.width/(2*this.chart.currentDevicePixelRatio), this.canvas.height/(2*this.chart.currentDevicePixelRatio)-legendOffset);
				}.bind(this)
			};
			
			console.log("creating chart...");			
			this.chart = new Chart(this.canvas.getContext('2d'), {
				type: 'doughnut',
				data: this.generateData(),
				plugins: [plugin],
				options: {
					aspectRatio: window.innerWidth >= 400 ? 1.5 : 1.1,
					cutoutPercentage: 80,
					tooltips: {
						custom: function(tooltipModel) {
							if(!tooltipModel.body || tooltipModel.body.length < 1){
								tooltipModel.caretSize = 0;
								tooltipModel.xPadding = 0;
								tooltipModel.yPadding = 0;
								tooltipModel.cornerRadius = 0;
								tooltipModel.width = 0;
								tooltipModel.height = 0;
							}
						},
						filter: this.onTooltipFilterCallback,
						callbacks: {
							label: this.onTooltipLabelCallback.bind(this),
						}
					},
					animation: {
						onProgress: function(animation){
							if(this.animationProgress == 1){
								return;
							}
							this.animationProgress = animation.animationObject.currentStep / animation.animationObject.numSteps;
						}.bind(this),
						onComplete: function(animation){
							this.animationProgress = 1;
						}.bind(this)
					},
					legend: {
						position: 'bottom',
						onClick: this.onLegendClick.bind(this)
					},
				}
			});
			window.addEventListener('resize', function(){
				setTimeout(this.update.bind(this), 100);
			}.bind(this));
		}
		
		onTooltipFilterCallback(tooltipItem, data) {
			return tooltipItem.index < 1;
		}
		
		onTooltipLabelCallback(tooltipItem, data){
			let label = data.labels[tooltipItem.index] || '';
						
			let value = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
			if(label){
				label += ': ';
			}
			label += value;
			label += this.unit;

			return label;
		}
		
		onLegendClick(e, legendItem){
			return;
		}
		
		generateData(){
			return {
				datasets: [{
					data: [this.value, Math.max(this.max-this.value, 0)],
					backgroundColor: ['rgba(0,255,0,1)', 'rgba(0,0,0,1)'],
					borderColor: ['rgba(0,255,0,1)', 'rgba(255,0,0,0)']
				}],
				labels: [this.legendName]
			}
		}
		
		getInnerDisplayValue(){
			return this.value;
		}
		
		updateData(){
			this.chart.data.datasets[0].data=[this.value, Math.max(this.max-this.value, 0)];
		}
		
		update(){
			this.updateData();
			this.chart.options.legend.display = this.canvas.width >= 400;
			this.chart.update();
		}
	}
	class InvertedDoughnutValue extends DoughnutValue{
		getInnerDisplayValue(){
			return this.max - this.value;
		}
	}
	class SOCDoughnutValue extends DoughnutValue{
		constructor(canvas, value, max, unit, legendName){
			super(canvas, value, max, unit, legendName)
			this.targetSOC = value
		}
		
		onTooltipFilterCallback(tooltipItem, data) {
			return tooltipItem.index < 2;
		}
		
		onTooltipLabelCallback(tooltipItem, data){
			let label = data.labels[tooltipItem.index] || '';
			
			let value = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
			if(label == "targetSOC"){
				value = this.targetSOC;
			}
			if(label){
				label += ': ';
			}
			label += value;
			label += this.unit;
			console.log(label);

			return label;
		}
		
		onLegendClick(e, legendItem){
			let index = legendItem.index;
			if(index == 0){
				return;
			}
			let n, i, a;
        	for(n = 0, i = (this.chart.data.datasets || []).length; n < i; ++n){
        		(a = this.chart.getDatasetMeta(n)).data[index] && (a.data[index].hidden = !a.data[index].hidden);
				if(index == 1){
					if(a.data[index].hidden){
						this.chart.data.datasets[0].data[2] = this.max-this.value;
					}else{
						this.chart.data.datasets[0].data[2] = this.max-Math.max(this.value, this.targetSOC);
					}
				}
        	}
        	this.chart.update();
		}
		
		generateData(){
			return {
				datasets: [{
					data: [this.value, Math.max(this.targetSOC-this.value, 0), this.max-Math.max(this.value, this.targetSOC)],
					backgroundColor: ['rgba(0,255,0,1)', 'rgba(0,0,0,1)', 'rgba(0,0,0,0)'],
					borderColor: ['rgba(0,255,0,1)', 'rgba(255,0,0,1)', 'rgba(0,0,0,0)']
				}],
				labels: [this.legendName, 'targetSOC']
			}
		}
		
		updateData(){
			this.chart.data.datasets[0].data=[this.value, Math.max(this.targetSOC-this.value, 0), this.max-Math.max(this.value, this.targetSOC)];
		}
	}
	//let soc = new DoughnutValue(document.getElementById("soc"), 80, 100, "%", "soc");
	
	let chargePower = new AnimatedValue(document.getElementById("chargePower"), 0, "kW", 1, 10);
	let chargeKMPH = new AnimatedValue(document.getElementById("chargeKMPH"), 0, "km/h");
	let range = new AnimatedValue(document.getElementById("range"), 0, "km");
	let targetTemp = new AnimatedValue(document.getElementById("hvactargettemp"), 0, "°C", 1, 10);
	let soc = new SOCDoughnutValue(document.getElementById("soc"), 0, 100, "%", "soc");
	soc.update();
	let chargeTimeRemaining = new InvertedDoughnutValue(document.getElementById("chargingTimeRemaining"), 0, 0, "min", "charging progress");
	
	async function getJSON(link){
		return (await fetch(link)).json();
	}
	
	function timetravelUser(selectedDates, dateStr, instance){
		console.log("select");
		timetravel(selectedDates[0]);
	}
	
	let timetravelStatus = false;
	let timetravelDate;
	
	function timetravel(date){
		console.log(date);
		if(date == false || date == undefined || date == null){
			timetravelStatus = false;
			updateCarStatus();
			return;
		}
	 	timetravelStatus = true;
		timetravelDate = "@"+(date.getTime() / 1000);
		updateCarStatus();
	}
	
	updateCarStatus();
	
	async function updateCarStatus(){
		const carStatus = await getJSON("carStatus.php"+(timetravelStatus ? "?at="+timetravelDate : ""));
		if(carStatus == undefined){
			alert("JSON fail");
			return;
		}
		if(carStatus.error != undefined){
			alert("fail");
			return;
		}
		processCarStatus(carStatus);
	}
	
	function processCarStatus(carStatus){
		soc.value = carStatus.batterysoc;
		soc.targetSOC = carStatus.targetsoc;
		soc.update();
		
		let now;
		if(timetravel){
			now = Date.parse(carStatus.time);
		}else{
			now = Date.now();
		}
		const elapsedMinutes = Math.round((now - Date.parse(carStatus.lastChargeStartTime)) / 60000);
		//console.log(elapsedMinutes);
		//console.log(carStatus.remainingchargingtime);
		//console.log(carStatus.lastChargeStartTime);
		const realTimeRemaining = now - Date.parse(carStatus.time) + parseInt(carStatus.remainingchargingtime);
		chargeTimeRemaining.max = elapsedMinutes + realTimeRemaining;
		chargeTimeRemaining.value = chargeTimeRemaining.max - realTimeRemaining;
		chargeTimeRemaining.update();
		
		range.setValue(carStatus.remainingrange);
		chargePower.setValue(carStatus.chargepower*10);
		chargeKMPH.setValue(carStatus.chargeratekmph);
		targetTemp.setValue(carStatus.hvactargettemp*10);
		
		let hvacstate;
		switch(carStatus.hvacstate){
			case "heating":
				hvacstate = "heating";
				document.getElementById("hvacstate").classList.add("heat");
				break;
			case "off":
				hvacstate = "hvac off";
				document.getElementById("hvacstate").classList.remove("heat");
				break;
			case "ventilation":
				hvacstate = "ventilating";
				document.getElementById("hvacstate").classList.remove("heat");
				break;
		}
		document.getElementById("hvacstate").innerHTML = hvacstate;
		
		if(carStatus.plugconnectionstate == "connected"){
			document.getElementById("chargingDisplay").style.display = "flex";
			let chargeState;
			switch(carStatus.chargestate){
				case "charging":
					chargeState = "charging...";
					break;
				case "chargePurposeReachedAndConservation":
					chargeState = "holding charge";
					break;
				case "readyForCharging":
					chargeState = "not charging";
					break;
				default:
					chargeState = "unknown: "+carStatus.chargeState;
			}
			document.getElementById("chargingState").innerHTML = chargeState + "<br>" + "Plug " + carStatus.pluglockstate;
		}else{
			document.getElementById("chargingDisplay").style.display = "none";
		}
	}
	
	
</script>